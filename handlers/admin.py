"""
Admin Control System

A comprehensive system for managing administrative functions in the
Anonymous Questions Bot. This system provides powerful tools for
question management, settings control, and system monitoring.

Features:
- Question management
- Settings control
- Statistics tracking
- User interaction
- Content moderation
- System monitoring
- Data management

Technical Features:
- Interactive UI
- State management
- Database integration
- Error handling
- Logging system
- Security controls
"""

from aiogram import Router, Bot
from aiogram.types import CallbackQuery, Message
from aiogram.filters import Command
from datetime import datetime
from sqlalchemy import select, func
import math

from config import (
    ADMIN_ID,
    ERROR_ADMIN_ONLY,
    SUCCESS_ADDED_TO_FAVORITES,
    SUCCESS_REMOVED_FROM_FAVORITES,
    SUCCESS_QUESTION_DELETED,
    ERROR_QUESTION_NOT_FOUND,
    SUCCESS_SETTING_UPDATED,
    ERROR_SETTING_UPDATE,
    ERROR_INVALID_VALUE,
    BOT_USERNAME, QUESTIONS_PER_PAGE,
    BACKUP_RECIPIENT_ID,
)
from models.database import async_session
from models.questions import Question
from keyboards.inline import (
    get_admin_question_keyboard,
    get_favorite_question_keyboard,
    get_stats_keyboard,
    get_clear_confirmation_keyboard,
    get_pagination_keyboard
)
from utils.logging_setup import get_logger
from handlers.admin_states import (
    start_answer_mode,
    cancel_answer_mode,

)
from models.settings import SettingsManager

router = Router()
logger = get_logger(__name__)

# Constants for pagination
MAX_PAGES_TO_SHOW = 10


@router.callback_query(lambda c: c.from_user.id == ADMIN_ID)
async def admin_question_callback(callback: CallbackQuery):
    """
    Process admin callback queries with comprehensive functionality.

    This handler provides:
    - Question management
    - Favorite handling
    - Pagination control
    - Data cleanup
    - Error handling

    Features:
    - Question answering
    - Favorites management
    - Content deletion
    - Pagination
    - Error recovery

    Flow:
    1. Validate callback
    2. Process action
    3. Update database
    4. Provide feedback

    Args:
        callback: Admin callback query
    """
    try:
        # Handle pagination callbacks
        if callback.data.startswith("pending_page:") or callback.data.startswith("favorites_page:"):
            await handle_pagination_callback(callback)
            return

        # Handle special callbacks without question ID
        if callback.data == "clear_all_questions":
            keyboard = get_clear_confirmation_keyboard()
            await callback.message.edit_text(
                "‚ö†Ô∏è <b>–í–Ω–∏–º–∞–Ω–∏–µ!</b>\n\n"
                "–í—ã —Å–æ–±–∏—Ä–∞–µ—Ç–µ—Å—å —É–¥–∞–ª–∏—Ç—å <b>–í–°–ï –≤–æ–ø—Ä–æ—Å—ã</b> –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.\n"
                "–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ <b>–Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ</b>!\n\n"
                "–£–¥–∞–ª–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–µ–ª—å–∑—è –±—É–¥–µ—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å.",
                reply_markup=keyboard
            )
            return

        elif callback.data == "confirm_clear_all":
            await handle_clear_all_questions(callback)
            return

        elif callback.data == "cancel_clear":
            await callback.message.edit_text(
                "‚ùå –û—á–∏—Å—Ç–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞",
                reply_markup=None
            )
            await callback.answer("–û—á–∏—Å—Ç–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞")
            return

        # Handle question-specific callbacks
        if ":" not in callback.data:
            await callback.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ", show_alert=True)
            return

        action, question_id_str = callback.data.split(":", 1)
        question_id = int(question_id_str)

        logger.info(f"Admin action: {action} on question {question_id}")

        # Handle answer cancellation
        if action == "cancel_answer":
            await cancel_answer_mode(callback)
            return

        async with async_session() as session:
            question = await session.get(Question, question_id)
            if not question or question.is_deleted:
                await callback.answer(ERROR_QUESTION_NOT_FOUND, show_alert=True)
                return

            if action == "answer":
                # Start interactive answer mode, passing the question object
                # to avoid creating another database session
                await start_answer_mode(callback, question_id, question)

            elif action == "favorite":
                question.is_favorite = not question.is_favorite
                await session.commit()

                message = SUCCESS_ADDED_TO_FAVORITES if question.is_favorite else SUCCESS_REMOVED_FROM_FAVORITES
                await callback.answer(message)

                # Update keyboard
                new_keyboard = get_admin_question_keyboard(
                    question_id, is_favorite=question.is_favorite)
                await callback.message.edit_reply_markup(reply_markup=new_keyboard)

            elif action == "remove_favorite":
                # Remove from favorites (from favorites list)
                question.is_favorite = False
                await session.commit()

                await callback.answer("‚≠ê –£–±—Ä–∞–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ")

                # Hide this question from favorites view
                await callback.message.edit_text(
                    f"‚≠ê <s>{callback.message.text}</s>\n\n<i>–£–±—Ä–∞–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ</i>",
                    reply_markup=None
                )

            elif action == "delete":
                question.is_deleted = True
                question.deleted_at = datetime.utcnow()
                await session.commit()

                await callback.answer(SUCCESS_QUESTION_DELETED)

                # Update message
                original_text = callback.message.text or ""
                deleted_text = f"üóëÔ∏è <s>{original_text}</s>\n\n<i>–í–æ–ø—Ä–æ—Å —É–¥–∞–ª–µ–Ω</i>"

                try:
                    await callback.message.edit_text(deleted_text, reply_markup=None)
                except Exception:
                    pass

            else:
                await callback.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ", show_alert=True)

    except Exception as e:
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", show_alert=True)
        logger.error(f"Error in admin callback: {e}")


async def handle_pagination_callback(callback: CallbackQuery):
    """
    Process pagination callbacks for question lists.

    This function:
    - Validates page numbers
    - Updates question lists
    - Handles navigation
    - Manages errors

    Features:
    - Page validation
    - List updating
    - Error handling
    - Activity logging

    Args:
        callback: Pagination callback query
    """
    try:
        # Parse callback data
        if callback.data.startswith("pending_page:"):
            page = int(callback.data.split(":")[1])
            await show_pending_questions_page(callback.message, page, edit_message=True)
        elif callback.data.startswith("favorites_page:"):
            page = int(callback.data.split(":")[1])
            await show_favorites_page(callback.message, page, edit_message=True)

        await callback.answer()

    except Exception as e:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É", show_alert=True)
        logger.error(f"Error in pagination: {e}")


async def show_pending_questions_page(message: Message, page: int = 0, edit_message: bool = False):
    """
    Display pending questions with pagination.

    This function provides:
    - Question listing
    - Page navigation
    - Empty state handling
    - Error recovery

    Features:
    - Dynamic loading
    - Page calculation
    - Empty handling
    - Error handling

    Flow:
    1. Count questions
    2. Calculate pages
    3. Load questions
    4. Display results

    Args:
        message: Telegram message
        page: Page number to show
        edit_message: Whether to edit existing message
    """
    try:
        async with async_session() as session:
            # Execute both queries in explicit sequence to prevent SQLite lock conflicts
            # First query: count total records
            total_stmt = select(func.count(Question.id)).where(
                Question.is_favorite == True,
                Question.is_deleted == False
            )
            total_result = await session.execute(total_stmt)
            total_count = total_result.scalar() or 0

            # Early return if no records found
            if total_count == 0:
                text = "‚≠ê –ù–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤."
                if edit_message:
                    await message.edit_text(text, reply_markup=None)
                else:
                    await message.answer(text)
                return

            # Calculate pagination parameters
            total_pages = math.ceil(total_count / QUESTIONS_PER_PAGE)
            page = max(0, min(page, total_pages - 1))
            offset = page * QUESTIONS_PER_PAGE

            # Second query: load actual records in same transaction
            # This prevents SQLite from creating separate lock contexts
            stmt = select(Question).where(
                Question.is_favorite == True,
                Question.is_deleted == False
            ).order_by(Question.created_at.desc()).offset(offset).limit(QUESTIONS_PER_PAGE)

            result = await session.execute(stmt)
            questions = result.scalars().all()

            # At this point we have both count and records from single session
            # No intermediate commits or rollbacks will occur

        # Create header message
        header_text = f"‚è≥ <b>–ù–µ–æ—Ç–≤–µ—á–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã</b>\n\nüìä –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1} –∏–∑ {total_pages} | –í—Å–µ–≥–æ: {total_count}"

        # Add pagination if needed
        keyboard = None
        if total_pages > 1:
            keyboard = get_pagination_keyboard(
                page, total_pages, "pending_page")

        if edit_message:
            await message.edit_text(header_text, reply_markup=keyboard)
        else:
            await message.answer(header_text, reply_markup=keyboard)

        # Send each question as separate message
        for question in questions:
            created_at = question.created_at.strftime("%d.%m.%Y %H:%M")
            favorite_mark = "‚≠ê " if question.is_favorite else ""

            question_text = f"""
‚ùì <b>{favorite_mark}–í–æ–ø—Ä–æ—Å #{question.id}</b>

{question.text}

üìÖ {created_at}
"""

            question_keyboard = get_admin_question_keyboard(
                question.id, is_favorite=question.is_favorite)
            await message.answer(question_text, reply_markup=question_keyboard)

        logger.info(
            f"Admin viewed pending questions page {page + 1}/{total_pages} ({len(questions)} questions)")

        # Add bottom navigation for better UX
        if total_pages > 1:
            bottom_nav_text = f"üìÑ –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º ({page + 1}/{total_pages})"
            bottom_keyboard = get_pagination_keyboard(
                page, total_pages, "pending_page")
            await message.answer(bottom_nav_text, reply_markup=bottom_keyboard)

        logger.info(
            f"Admin viewed pending questions page {page + 1}/{total_pages} ({len(questions)} questions)")

    except Exception as e:
        error_text = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–µ–æ—Ç–≤–µ—á–µ–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤"
        if edit_message:
            await message.edit_text(error_text, reply_markup=None)
        else:
            await message.answer(error_text)
        logger.error(f"Error getting pending questions: {e}")


async def show_favorites_page(message: Message, page: int = 0, edit_message: bool = False):
    """
    Display favorite questions with pagination.

    This function provides:
    - Favorite listing
    - Page navigation
    - Status tracking
    - Error recovery

    Features:
    - Dynamic loading
    - Page calculation
    - Status display
    - Error handling

    Flow:
    1. Count favorites
    2. Calculate pages
    3. Load questions
    4. Display results

    Args:
        message: Telegram message
        page: Page number to show
        edit_message: Whether to edit existing message
    """
    try:
        async with async_session() as session:
            # Count total favorite questions
            total_stmt = select(func.count(Question.id)).where(
                Question.is_favorite == True,
                Question.is_deleted == False
            )
            total_result = await session.execute(total_stmt)
            total_count = total_result.scalar() or 0

            if total_count == 0:
                text = "‚≠ê –ù–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤."
                if edit_message:
                    await message.edit_text(text, reply_markup=None)
                else:
                    await message.answer(text)
                return

            # Calculate pagination
            total_pages = math.ceil(total_count / QUESTIONS_PER_PAGE)
            # Ensure page is in bounds
            page = max(0, min(page, total_pages - 1))
            offset = page * QUESTIONS_PER_PAGE

            # Get questions for current page
            stmt = select(Question).where(
                Question.is_favorite == True,
                Question.is_deleted == False
            ).order_by(Question.created_at.desc()).offset(offset).limit(QUESTIONS_PER_PAGE)

            result = await session.execute(stmt)
            questions = result.scalars().all()

        # Create header message
        header_text = f"‚≠ê <b>–ò–∑–±—Ä–∞–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã</b>\n\nüìä –°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1} –∏–∑ {total_pages} | –í—Å–µ–≥–æ: {total_count}"

        # Add pagination if needed
        keyboard = None
        if total_pages > 1:
            keyboard = get_pagination_keyboard(
                page, total_pages, "favorites_page")

        if edit_message:
            await message.edit_text(header_text, reply_markup=keyboard)
        else:
            await message.answer(header_text, reply_markup=keyboard)

        # Send each question as separate message
        for question in questions:
            created_at = question.created_at.strftime("%d.%m.%Y %H:%M")
            status = "‚úÖ –û—Ç–≤–µ—á–µ–Ω" if question.is_answered else "‚è≥ –û–∂–∏–¥–∞–µ—Ç –æ—Ç–≤–µ—Ç–∞"

            question_text = f"""
‚≠ê <b>–í–æ–ø—Ä–æ—Å #{question.id}</b>

{question.text}

üìÖ {created_at} | {status}"""

            if question.answer:
                question_text += f"\n\nüí¨ <b>–û—Ç–≤–µ—Ç:</b>\n{question.answer}"

            keyboard = get_favorite_question_keyboard(question.id)
            await message.answer(question_text, reply_markup=keyboard)

        logger.info(
            f"Admin viewed favorites page {page + 1}/{total_pages} ({len(questions)} questions)")

# Add bottom navigation for better UX - users don't need to scroll back up
        if total_pages > 1:
            bottom_nav_text = f"üìÑ –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º ({page + 1}/{total_pages})"
            bottom_keyboard = get_pagination_keyboard(
                page, total_pages, "favorites_page")
            await message.answer(bottom_nav_text, reply_markup=bottom_keyboard)

        logger.info(
            f"Admin viewed favorites page {page + 1}/{total_pages} ({len(questions)} questions)")

    except Exception as e:
        error_text = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤"
        if edit_message:
            await message.edit_text(error_text, reply_markup=None)
        else:
            await message.answer(error_text)
        logger.error(f"Error getting favorite questions: {e}")


async def handle_clear_all_questions(callback: CallbackQuery):
    """
    Process database cleanup request.

    This function:
    - Validates request
    - Performs cleanup
    - Updates status
    - Handles errors

    Features:
    - Safe deletion
    - Status tracking
    - Error handling
    - Activity logging

    Flow:
    1. Confirm action
    2. Delete questions
    3. Update status
    4. Log changes

    Args:
        callback: Cleanup confirmation callback
    """
    try:
        async with async_session() as session:
            # Mark all questions as deleted
            stmt = select(Question).where(Question.is_deleted == False)
            result = await session.execute(stmt)
            questions = result.scalars().all()

            deleted_count = 0
            for question in questions:
                question.is_deleted = True
                question.deleted_at = datetime.utcnow()
                deleted_count += 1

            await session.commit()

            await callback.message.edit_text(
                f"‚úÖ –£–¥–∞–ª–µ–Ω–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {deleted_count}",
                reply_markup=None
            )
            await callback.answer("–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            logger.warning(f"Admin cleared {deleted_count} questions")

    except Exception as e:
        await callback.message.edit_text(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö",
            reply_markup=None
        )
        await callback.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ", show_alert=True)
        logger.error(f"Error clearing database: {e}")


@router.message(Command("test"))
async def test_command(message: Message):
    """
    Test bot functionality and permissions.

    This command:
    - Validates permissions
    - Tests features
    - Reports status

    Features:
    - Permission check
    - Feature testing
    - Status reporting
    - Error handling

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    await message.answer("‚úÖ –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ\n\nüë§ –í—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä")


@router.message(Command("admin"))
async def admin_command(message: Message):
    """
    Display admin control panel.

    This command provides:
    - Command overview
    - Feature access
    - Status display
    - Help information

    Features:
    - Command listing
    - Permission check
    - Help display
    - Error handling

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    admin_help = f"""
üõ† <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –±–æ—Ç–∞</b>

üìã <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏:</b>
‚Ä¢ /set_author - –ò–∑–º–µ–Ω–∏—Ç—å –∏–º—è –∞–≤—Ç–æ—Ä–∞
‚Ä¢ /set_info - –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞
‚Ä¢ /settings - –ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ–∫—É—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫

üìä <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–∞–º–∏:</b>
‚Ä¢ /pending - –ù–µ–æ—Ç–≤–µ—á–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã
‚Ä¢ /favorites - –ò–∑–±—Ä–∞–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã
‚Ä¢ /stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞

üîó <b>–°—Å—ã–ª–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b>
<code>https://t.me/{BOT_USERNAME}?start=channel</code>

<i>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤–∏–¥—è—Ç —Ç–æ–ª—å–∫–æ –∫–æ–º–∞–Ω–¥—É /start</i>
"""

    await message.answer(admin_help)
    logger.info(f"Admin {message.from_user.id} viewed help")


@router.message(Command("favorites"))
async def favorites_command(message: Message):
    """
    Display favorite questions list.

    This command provides:
    - Favorites listing
    - Page navigation
    - Question management
    - Status tracking

    Features:
    - Dynamic loading
    - Pagination
    - Status display
    - Error handling

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    await show_favorites_page(message)


@router.message(Command("pending"))
async def pending_command(message: Message):
    """
    Display pending questions list.

    This command provides:
    - Question listing
    - Page navigation
    - Answer management
    - Status tracking

    Features:
    - Dynamic loading
    - Pagination
    - Status display
    - Error handling

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    await show_pending_questions_page(message)


@router.message(Command("stats"))
async def stats_command(message: Message):
    """
    Display bot statistics and metrics.

    This command provides:
    - Usage statistics
    - Question metrics
    - System status
    - Performance data

    Features:
    - Data aggregation
    - Metric calculation
    - Status display
    - Error handling

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    try:
        async with async_session() as session:
            # Get total questions count
            total_stmt = select(func.count(Question.id)).where(
                Question.is_deleted == False
            )
            total_result = await session.execute(total_stmt)
            total_questions = total_result.scalar() or 0

            # Get answered questions count
            answered_stmt = select(func.count(Question.id)).where(
                Question.is_deleted == False,
                Question.answer.isnot(None)
            )
            answered_result = await session.execute(answered_stmt)
            answered_questions = answered_result.scalar() or 0

            # Get pending questions count
            pending_stmt = select(func.count(Question.id)).where(
                Question.is_deleted == False,
                Question.answer.is_(None)
            )
            pending_result = await session.execute(pending_stmt)
            pending_questions = pending_result.scalar() or 0

            # Get favorite questions count
            favorite_stmt = select(func.count(Question.id)).where(
                Question.is_deleted == False,
                Question.is_favorite == True
            )
            favorite_result = await session.execute(favorite_stmt)
            favorite_questions = favorite_result.scalar() or 0

            # Get deleted questions count
            deleted_stmt = select(func.count(Question.id)).where(
                Question.is_deleted == True
            )
            deleted_result = await session.execute(deleted_stmt)
            deleted_questions = deleted_result.scalar() or 0

            # Calculate answer rate
            answer_rate = round(
                (answered_questions / total_questions * 100) if total_questions > 0 else 0, 1)

            stats_text = f"""
üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>

üìù <b>–í–æ–ø—Ä–æ—Å—ã:</b>
‚Ä¢ –í—Å–µ–≥–æ: {total_questions}
‚Ä¢ –û—Ç–≤–µ—á–µ–Ω–æ: {answered_questions}
‚Ä¢ –û–∂–∏–¥–∞—é—Ç: {pending_questions}
‚Ä¢ –í –∏–∑–±—Ä–∞–Ω–Ω–æ–º: {favorite_questions}
‚Ä¢ –£–¥–∞–ª–µ–Ω–æ: {deleted_questions}

üìà <b>–ü–æ–∫–∞–∑–∞—Ç–µ–ª–∏:</b>
‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç–≤–µ—Ç–æ–≤: {answer_rate}%
"""

            keyboard = get_stats_keyboard()
            await message.answer(stats_text, reply_markup=keyboard)
            logger.info(f"Admin {message.from_user.id} viewed statistics")

    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
        logger.error(f"Error getting statistics: {e}")


@router.message(Command("set_author"))
async def set_author_command(message: Message):
    """
    Update author name setting.

    This command provides:
    - Setting validation
    - Value updating
    - Status feedback
    - Error handling

    Features:
    - Input validation
    - Database update
    - Status display
    - Error recovery

    Flow:
    1. Validate input
    2. Update setting
    3. Confirm change
    4. Handle errors

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    # Check if command has argument
    command_parts = message.text.split(maxsplit=1)
    if len(command_parts) < 2:
        current_name = await SettingsManager.get_author_name()
        await message.answer(
            f"‚ÑπÔ∏è –¢–µ–∫—É—â–µ–µ –∏–º—è –∞–≤—Ç–æ—Ä–∞: <b>{current_name}</b>\n\n"
            "üìù –ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ:\n"
            "/set_author <i>–Ω–æ–≤–æ–µ –∏–º—è</i>"
        )
        return

    new_name = command_parts[1].strip()
    if not new_name:
        await message.answer(ERROR_INVALID_VALUE)
        return

    try:
        await SettingsManager.set_author_name(new_name)
        await message.answer(
            SUCCESS_SETTING_UPDATED.format(
                setting="–∏–º—è –∞–≤—Ç–æ—Ä–∞",
                value=new_name
            )
        )
        logger.info(f"Admin updated author name to: {new_name}")
    except Exception as e:
        await message.answer(ERROR_SETTING_UPDATE)
        logger.error(f"Error updating author name: {e}")


@router.message(Command("set_info"))
async def set_info_command(message: Message):
    """
    Update author info setting.

    This command provides:
    - Setting validation
    - Value updating
    - Status feedback
    - Error handling

    Features:
    - Input validation
    - Database update
    - Status display
    - Error recovery

    Flow:
    1. Validate input
    2. Update setting
    3. Confirm change
    4. Handle errors

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    # Check if command has argument
    command_parts = message.text.split(maxsplit=1)
    if len(command_parts) < 2:
        current_info = await SettingsManager.get_author_info()
        await message.answer(
            f"‚ÑπÔ∏è –¢–µ–∫—É—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ: <b>{current_info}</b>\n\n"
            "üìù –ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ:\n"
            "/set_info <i>–Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ</i>"
        )
        return

    new_info = command_parts[1].strip()
    if not new_info:
        await message.answer(ERROR_INVALID_VALUE)
        return

    try:
        await SettingsManager.set_author_info(new_info)
        await message.answer(
            SUCCESS_SETTING_UPDATED.format(
                setting="–æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞",
                value=new_info
            )
        )
        logger.info(f"Admin updated author info to: {new_info}")
    except Exception as e:
        await message.answer(ERROR_SETTING_UPDATE)
        logger.error(f"Error updating author info: {e}")


@router.message(Command("settings"))
async def settings_command(message: Message):
    """
    Display current bot settings.

    This command provides:
    - Settings overview
    - Value display
    - Help information
    - Error handling

    Features:
    - Settings loading
    - Value formatting
    - Help display
    - Error recovery

    Args:
        message: Command message
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    try:
        author_name = await SettingsManager.get_author_name()
        author_info = await SettingsManager.get_author_info()

        settings_text = f"""
‚öôÔ∏è <b>–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞</b>

üë§ <b>–ò–º—è –∞–≤—Ç–æ—Ä–∞:</b>
{author_name}

‚ÑπÔ∏è <b>–û–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞:</b>
{author_info}

üìù <b>–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:</b>
‚Ä¢ /set_author - –∏–∑–º–µ–Ω–∏—Ç—å –∏–º—è
‚Ä¢ /set_info - –∏–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ
"""

        await message.answer(settings_text)
        logger.info(f"Admin {message.from_user.id} viewed settings")

    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫")
        logger.error(f"Error getting settings: {e}")


def get_questions_per_page() -> int:
    """
    Get questions per page setting from config.
    """
    return QUESTIONS_PER_PAGE


# =============================================================================
# BACKUP MANAGEMENT COMMANDS
# =============================================================================

@router.message(Command("backup"))
async def cmd_create_backup(message: Message, bot: Bot):
    """Create manual backup and send to configured recipient."""
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    status_msg = await message.answer("üîÑ –°–æ–∑–¥–∞—é —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é...")

    try:
        from utils.telegram_backup import create_and_send_backup

        # Send to configured recipient (must be set in .env)
        success = await create_and_send_backup(BACKUP_RECIPIENT_ID, bot)

        if success:
            if BACKUP_RECIPIENT_ID == message.from_user.id:
                await status_msg.edit_text(
                    "‚úÖ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤–∞–º –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è!\n\n"
                    "üìÅ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ö–æ–¥—è—â–∏–µ —Ñ–∞–π–ª—ã –≤ —ç—Ç–æ–º —á–∞—Ç–µ"
                )
            else:
                await status_msg.edit_text(
                    f"‚úÖ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {BACKUP_RECIPIENT_ID}\n\n"
                    f"üìÅ –§–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –∏ –ª–æ–≥–∏ –±–æ—Ç–∞"
                )
        else:
            await status_msg.edit_text(
                "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏\n\n"
                "üìã –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"
            )

    except Exception as e:
        await status_msg.edit_text(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –±–µ–∫–∞–ø–∞: {e}")
        logger.error(f"Backup command failed: {e}")


@router.message(Command("backup_me"))
async def cmd_backup_to_me(message: Message, bot: Bot):
    """Create backup and send directly to current admin user."""
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    status_msg = await message.answer("üîÑ –°–æ–∑–¥–∞—é –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é...")

    try:
        from utils.telegram_backup import create_and_send_backup

        success = await create_and_send_backup(message.from_user.id, bot)

        if success:
            await status_msg.edit_text(
                "‚úÖ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!\n\n"
                "üìÅ –§–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç:\n"
                "‚Ä¢ –ü–æ–ª–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –±–æ—Ç–∞\n"
                "‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤\n"
                "‚Ä¢ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é\n\n"
                "‚ö†Ô∏è –•—Ä–∞–Ω–∏—Ç–µ —Ñ–∞–π–ª –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ"
            )
        else:
            await status_msg.edit_text(
                "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–π —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏"
            )

    except Exception as e:
        await status_msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")
        logger.error(f"Personal backup command failed: {e}")


@router.message(Command("backup_to"))
async def cmd_backup_to_user(message: Message, bot: Bot):
    """Send backup to specific user ID."""
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    # Parse user ID from command arguments
    try:
        command_parts = message.text.split()
        if len(command_parts) != 2:
            await message.answer(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã\n\n"
                "üìù –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /backup_to USER_ID\n"
                "üìù –ü—Ä–∏–º–µ—Ä: /backup_to 123456789\n\n"
                "üí° –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è ID –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ @userinfobot"
            )
            return

        recipient_id = int(command_parts[1])

        # Validate user ID format
        if recipient_id <= 0:
            await message.answer("‚ùå ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º")
            return

    except ValueError:
        await message.answer(
            "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n"
            "ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä: 123456789"
        )
        return

    status_msg = await message.answer(f"üîÑ –°–æ–∑–¥–∞—é —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {recipient_id}...")

    try:
        from utils.telegram_backup import create_and_send_backup

        success = await create_and_send_backup(recipient_id, bot)

        if success:
            await status_msg.edit_text(
                f"‚úÖ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {recipient_id}\n\n"
                f"üìÅ –§–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –∏ –ª–æ–≥–∏\n"
                f"üìã –í–∫–ª—é—á–µ–Ω—ã –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é"
            )
        else:
            await status_msg.edit_text(
                f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {recipient_id}\n\n"
                "–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n"
                "‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞\n"
                "‚Ä¢ –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n"
                "‚Ä¢ –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞—Ä—Ö–∏–≤–∞"
            )

    except Exception as e:
        await status_msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")
        logger.error(f"Backup to user {recipient_id} failed: {e}")


@router.message(Command("backup_info"))
async def cmd_backup_info(message: Message):
    """Show backup system information and status."""
    if message.from_user.id != ADMIN_ID:
        await message.answer(ERROR_ADMIN_ONLY)
        return

    try:
        from config import BACKUP_ENABLED, BACKUP_RECIPIENT_ID, BACKUP_STORAGE_DIR

        # Format backup information
        info_text = "üì¶ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∏—Å—Ç–µ–º–µ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è\n\n"

        # System status
        status_emoji = "‚úÖ" if BACKUP_ENABLED else "‚ùå"
        info_text += f"{status_emoji} –°—Ç–∞—Ç—É—Å: {'–í–∫–ª—é—á–µ–Ω–∞' if BACKUP_ENABLED else '–û—Ç–∫–ª—é—á–µ–Ω–∞'}\n"

        if BACKUP_ENABLED:
            info_text += f"üë§ –ü–æ–ª—É—á–∞—Ç–µ–ª—å: {BACKUP_RECIPIENT_ID}\n"
            info_text += f"üìÅ –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ: {BACKUP_STORAGE_DIR}\n"
            info_text += f"‚è∞ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ: –ö–∞–∂–¥—ã–µ 24 —á–∞—Å–∞\n\n"

            info_text += "üìã –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –±–µ–∫–∞–ø–∞:\n"
            info_text += "‚Ä¢ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –±–æ—Ç–∞ (database.db)\n"
            info_text += "‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–µ –ª–æ–≥–∏ (100KB)\n"
            info_text += "‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–∞–±–ª–∏—Ü –ë–î\n"
            info_text += "‚Ä¢ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é\n\n"

            info_text += "üîß –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            info_text += "‚Ä¢ /backup - —Å–æ–∑–¥–∞—Ç—å –±–µ–∫–∞–ø –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—è\n"
            info_text += "‚Ä¢ /backup_me - —Å–æ–∑–¥–∞—Ç—å –±–µ–∫–∞–ø –¥–ª—è —Å–µ–±—è\n"
            info_text += "‚Ä¢ /backup_to ID - –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –±–µ–∫–∞–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n"
            info_text += "‚Ä¢ /backup_info - —ç—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è\n\n"

            info_text += "‚ö†Ô∏è –í–∞–∂–Ω–æ:\n"
            info_text += "‚Ä¢ –ë–µ–∫–∞–ø—ã –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ Telegram\n"
            info_text += "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: 50MB\n"
            info_text += "‚Ä¢ –õ–æ–∫–∞–ª—å–Ω—ã–µ –∫–æ–ø–∏–∏ —É–¥–∞–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏"
        else:
            info_text += "\n‚öôÔ∏è –î–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤ .env:\n"
            info_text += "BACKUP_ENABLED=true\n"
            info_text += "BACKUP_RECIPIENT_ID=–≤–∞—à_telegram_id"

        await message.answer(info_text)
        logger.info(f"Admin {message.from_user.id} viewed backup information")

    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–µ–∫–∞–ø–∞—Ö")
        logger.error(f"Error getting backup info: {e}")
