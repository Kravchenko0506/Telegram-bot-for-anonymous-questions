"""Admin state management for answering questions."""
from aiogram import Router
from aiogram.types import Message, CallbackQuery
from datetime import datetime, timedelta

from config import ADMIN_ID, USER_ANSWER_RECEIVED
from models.database import async_session
from models.questions import Question
from utils.logging_setup import get_logger
from models.user_states import UserStateManager
from keyboards.inline import get_cancel_answer_keyboard, get_user_question_sent_keyboard

router = Router()
logger = get_logger(__name__)

# In-memory storage for admin answer states
admin_answer_states = {}

def preview_text(text: str, max_len: int = 100) -> str:
    """Truncate text for preview."""
    return text if len(text) <= max_len else text[:max_len] + "..."

def cleanup_expired_states():
    """Remove states older than 30 minutes."""
    cutoff = datetime.utcnow() - timedelta(minutes=30)
    expired = [
        admin_id for admin_id, state in admin_answer_states.items()
        if state.get('created_at', cutoff) < cutoff
    ]
    
    for admin_id in expired:
        admin_answer_states.pop(admin_id, None)
        logger.warning(f"Cleaned expired state for admin {admin_id}")

def is_admin_answering(admin_id: int) -> bool:
    """Check if admin is currently answering."""
    cleanup_expired_states()
    state = admin_answer_states.get(admin_id)
    return state and state.get('mode') == 'waiting_answer'

async def start_answer_mode(callback: CallbackQuery, question_id: int, question=None):
    """Enter answer mode for a question."""
    admin_id = callback.from_user.id
    cleanup_expired_states()

    try:
        # Fetch question if not provided
        if not question:
            async with async_session() as session:
                question = await session.get(Question, question_id)
        
        if not question or question.is_deleted:
            await callback.answer("‚ùå –í–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return
            
        if question.is_answered:
            await callback.answer("‚ùå –£–∂–µ –æ—Ç–≤–µ—á–µ–Ω", show_alert=True)
            return

        # Set answer state
        admin_answer_states[admin_id] = {
            'question_id': question_id,
            'question_text': question.text or "",
            'user_id': question.user_id,
            'mode': 'waiting_answer',
            'created_at': datetime.utcnow()
        }

        # Show answer interface
        await callback.message.reply(
            f"üí¨ <b>–û—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å #{question_id}</b>\n\n"
            f"<b>–í–æ–ø—Ä–æ—Å:</b>\n<i>{question.text}</i>\n\n"
            "üìù <b>–ù–∞–ø–∏—à–∏—Ç–µ –æ—Ç–≤–µ—Ç:</b>\n"
            "<i>‚è∞ –†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç–∫–ª—é—á–∏—Ç—Å—è —á–µ—Ä–µ–∑ 30 –º–∏–Ω—É—Ç</i>",
            reply_markup=get_cancel_answer_keyboard(question_id)
        )
        await callback.answer("üí° –í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏")
        logger.info(f"Admin {admin_id} answering question {question_id}")

    except Exception as e:
        admin_answer_states.pop(admin_id, None)
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞ –≤ —Ä–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞", show_alert=True)
        logger.error(f"Start answer error: {e}")

async def handle_admin_answer(message: Message):
    """Process admin's answer to a question."""
    admin_id = message.from_user.id
    cleanup_expired_states()
    
    state = admin_answer_states.get(admin_id)
    if not state or state.get('mode') != 'waiting_answer':
        admin_answer_states.pop(admin_id, None)
        return False

    answer_text = message.text.strip()
    if not answer_text:
        await message.answer("‚ùå –û—Ç–≤–µ—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
        return True

    # Extract state data
    question_id = state['question_id']
    user_id = state['user_id']
    question_text = state['question_text']
    
    # Clear state immediately
    del admin_answer_states[admin_id]
    
    try:
        # Save answer to DB
        async with async_session() as session:
            question = await session.get(Question, question_id)
            if not question or question.is_answered:
                await message.answer("‚ùå –í–æ–ø—Ä–æ—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                return True
                
            question.answer = answer_text
            question.answered_at = datetime.utcnow()
            await session.commit()

        # Notify user
        await _notify_user_with_answer(message, user_id, question_text, answer_text)
        
        # Confirm to admin
        await message.answer(
            "‚úÖ <b>–û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!</b>\n\n"
            f"<b>–í–æ–ø—Ä–æ—Å:</b> {preview_text(question_text)}\n"
            f"<b>–û—Ç–≤–µ—Ç:</b> {preview_text(answer_text)}\n\n"
            "<i>–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –∞–Ω–æ–Ω–∏–º–Ω–æ</i>"
        )
        logger.info(f"Answer sent for question {question_id}")
        return True
        
    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è")
        logger.error(f"Save answer error: {e}")
        return True

async def _notify_user_with_answer(message: Message, user_id: int, question_text: str, answer_text: str):
    """Send answer to user with error handling."""
    try:
        await message.bot.send_message(
            chat_id=user_id,
            text=USER_ANSWER_RECEIVED.format(question=question_text, answer=answer_text) +
                 "\n\nüí¨ <b>–•–æ—Ç–∏—Ç–µ –∑–∞–¥–∞—Ç—å –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å?</b>",
            reply_markup=get_user_question_sent_keyboard()
        )
        await UserStateManager.set_user_state(user_id, UserStateManager.STATE_QUESTION_SENT)
        
    except Exception as e:
        logger.error(f"Failed to notify user {user_id}: {e}")
        await message.answer(
            "‚úÖ <b>–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!</b>\n\n"
            f"<b>–í–æ–ø—Ä–æ—Å:</b> {preview_text(question_text)}\n"
            f"<b>–û—Ç–≤–µ—Ç:</b> {preview_text(answer_text)}\n\n"
            "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"
        )

async def cancel_answer_mode(callback_or_message):
    """Cancel answer mode - accepts CallbackQuery or Message."""
    # Handle both CallbackQuery and Message
    if hasattr(callback_or_message, 'from_user'):
        # It's a CallbackQuery
        admin_id = callback_or_message.from_user.id
        callback = callback_or_message
        message = callback.message
    else:
        # It's a Message (from try/except in admin.py)
        admin_id = ADMIN_ID  # Admin is the only one who can cancel
        callback = None
        message = callback_or_message
    
    state = admin_answer_states.pop(admin_id, None)
    if state:
        await message.edit_text("‚ùå –†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω", reply_markup=None)
        if callback:
            await callback.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")
        logger.info(f"Admin {admin_id} canceled answer for {state['question_id']}")
    else:
        if callback:
            await callback.answer("–†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω")
        else:
            logger.warning(f"Admin {admin_id} tried to cancel non-active answer mode")

# Legacy compatibility
def is_admin_in_answer_mode(admin_id: int) -> bool:
    """Legacy function name - use is_admin_answering instead."""
    return is_admin_answering(admin_id)

def force_clear_admin_state(admin_id: int) -> bool:
    """Force clear admin state."""
    return bool(admin_answer_states.pop(admin_id, None))